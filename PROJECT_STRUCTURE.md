> Last Updated: 2024-05-24

# Бизнес-презентация возможностей бэкенда

**Commission Tracker Backend** — это не просто база данных. Это интеллектуальное, автоматизированное и масштабируемое ядро для управления всем циклом комиссионных вознаграждений в **страховом агентстве или брокере**. Система спроектирована для обеспечения прозрачности, минимизации ручного труда и гарантированной точности расчетов в соответствии с требованиями FCA.

---

## Ключевые бизнес-возможности

### 1. Полный цикл управления страховыми полисами

Система позволяет отслеживать любой страховой полис от создания до продления или отмены.

-   **Что это дает?** Полная прозрачность. Менеджмент и консультанты в любой момент видят, на какой стадии находится каждый полис, что устраняет неопределенность и позволяет прогнозировать доход.
-   **Как это работает?** Консультант (`Adviser`) регистрирует полис, привязы��ает его к клиенту и страховой компании (`Insurer`), и обновляет его статус по мере продвижения. Система надежно хранит всю историю.

### 2. Автоматический расчет сложных комиссий

Это **главное преимущество** системы. Ручн��й расчет комиссий по страхованию — это источник ошибок и задержек. Наш бэкенд полностью автоматизирует этот процесс.

-   **Что это дает?**
    -   **Точность 100%**: Исключен человеческий фактор при расчете удержаний, бонусов и возвратов.
    -   **Мгновенный расчет**: Комиссия рассчитывается, как только полис помечается как активный (`ACTIVE`).
    -   **Прозрачность**: Консультант сразу видит заработанную сумму, что повышает мотивацию.
-   **Как это работает?** Как только статус полиса меняется на `ACTIVE`, система автоматически "ловит" это событие, находит соответствующий комиссионный план и производит расчет на основе данных полиса (например, годовой премии). Никаких ручных действий не требуется.

### 3. Безопасное управление ролями и доступом

Система четко разделяет, кто и что может видеть и делать.

-   **Что это дает?** Безопасность и конфиденциальность данных. Консультанты видят только своих клиентов и свои полисы. ��уководство видит полную картину по всей компании.
-   **Как это работает?** Каждый API-запрос проверяется на соответствие прав доступа. `Adviser` физически не сможет получить доступ к данным другого консультанта.

### 4. Асинхронные уведомления и операции

Система не "зависает" при выполнении долгих задач.

-   **Что это дает?** Отличный пользовательский опыт и готовность к нагрузкам. Отправка email-уведомлений, генерация отчетов или другие сложные вычисления происходят в фоновом режиме, не мешая работе пользователя.
-   **Как это работает?** Мы используем технологию Celery. Когда нужно отправить email, система не ждет ответа от почтового сервера, а просто ставит задачу в очередь и мгновенно отвечает пользователю. Специальный фоновый процесс (worker) выполняет эту задачу.

---

## Техническое совершенство (Почему это решение "Топ 1")

-   **Масштабируемость ("Готовность к росту")**: Сегодня система специализируется на страховании жизни и здоровья. Завтра нужно добавить "Страхование имущества"? Благодаря нашей архитектуре, это не потребует переписывания всего проекта. Это будет простая, предс��азуемая задача.
-   **Надежность ("Качество в каждой строке")**: Мы не просто надеемся, что код работает. Мы это **гарантируем**. Каждый коммит автоматически проверяется на ошибки, соответствие стилю и проходит полный набор тестов. Это защищает бизнес от сбоев.
-   **Безопасность ("Данные под замком")**: Все секретные ключи и пароли хранятся вне кода, в защ��щенных `.env` файлах. Система прав доступа, как описано выше, встроена в самое ядро API.

---

## Как с этим работать (Интеграция и использование)

Бэкенд спроектирован так, чтобы с ним было максимально легко и приятно работать другим командам (например, фронтенду).

-   **Единый и понятный API**: Вся бизнес-логика доступна через хорошо структурированный REST API.
-   **Интерактивная документация (Swagger)**: Команде фронтенда не нужно гадать, как работает API. Они могут открыть в браузере страницу `/api/schema/swagger-ui/`, увидеть все доступные эндпоинты, их параметры и даже **отправить тестовые запросы** прямо оттуда. Это ускоряет разработку в разы.
-   **Простая аутентификация**: Процесс входа в систему стандартизирован и безопасен, он основан на токенах.

**Итог:** Commission Tracker Backend — это не просто программа, а надежная, безопасная и готовая к росту плат��орма, которая автоматизирует ключевой бизнес-процесс и служит прочным фундаментом для дальнейшего развития продукта.

---
---

# Commission Tracker Backend - Подробная архитектура проекта

Этот документ — исчерпывающее руководство по бэкенд-архитектуре. Он объясняет назначение каждого ключевого компонента, принципы его работы и то, как они взаимодействуют друг с другом.

## Ключевые архитектурные принципы

1.  **DRY (Don't Repeat Yourself / Не повторяйся)**: Это главный принцип, которому мы следовали. Вместо того чтобы писать одинаковый код для ипотек и полис��в, мы вынесл�� в��ю общую логику в переиспользуемые компоненты.
2.  **Масштабируемость**: Архитектура с��р��ектирована так, чтобы добавление нового типа сделок (например, "Автокредиты") занимало минимум времени и усилий.
3.  **Четкое разделение ответственности (Single Responsibility)**: Каждый компонент выполняет одну конкретную задачу. Это делает код предсказуемым и легким ����ля отладки.

---

## Ядро архитектуры: Переиспользуемые компоненты (`commission_tracker/`)

Это сердце нашего проекта. Эти компоненты находятся в главной директории `commission_tracker/` и используются всеми приложениями.

### `api_mixins.py` — "Усилители" для API

Здесь живу�� "миксины" — классы, кот��рые добавляют дополнительную функциональность нашим API-компонентам (`ViewSet`).

-   **`OwnerViewSetMixin`**: Решает две задачи, связанные с "владельцем" за��иси:
    1.  **Фильтрация (`get_queryset`)**: Когда пользователь запрашивает список сделок, этот метод проверяет: если пользователь — админ (`is_staff`), он отдает все сделки. Если нет — отдает только те, где `user` равен текущ����му пользователю.
    2.  **Авто-присвоение (`perform_create`)**: Когда пользователь создает новую сделку, этот метод "перехватывает" сохранение и автоматически подставляет `request.user` в поле `user` новой записи.

-   **`StatusUpdateViewSetMixin`**: Добавляет к API специальный URL-адрес (эндпоинт) вида `/api/mortgages/1/status/`.
    > Декоратор `@action(detail=True, methods=['patch'])` гов��рит Django: "Со��дай новый эндпоинт для этого ViewSet, который будет доступен для конкретного объекта (`detail=True`) и будет принимать PATCH-запросы".
    Это позволяет безопасно изменять **только** статус сделки, не затрагивая другие поля.

> **Как это работает вместе?**
> В `apps/mortgage/api_views.py` мы пишем:
> ```python
> class MortgageViewSet(OwnerViewSetMixin, StatusUpdateViewSetMixin, viewsets.ModelViewSet):
>     # ...
> ```
> И `MortgageViewSet` мгновенно получает всю эту мощную логику, не написав ни строчки повторяющегося кода. (Примечание: это пример старой архитектуры. Новые модули, такие как `PolicyViewSet`, будут использовать те же принципы).

### `serializers.py` — "Переводчики" данных

Здесь живут базовые классы для "сериализаторов" — компонентов, которые преобразуют данные из базы в формат JSON (для фронтенда) и обратно.

-   **`BaseOwnerModelSerializer`**: Его задача — защитить важные поля.
    > `read_only_fields = ('user', 'status')` говорит: "Поля `user` и `status` можно только читать. Их нельзя изменять через обычные POST или PUT/PATCH запросы". Это предотвращает случайное или намеренное изменение владельца или статуса сделки в обход нашей логики.

-   **`StatusUpdateSerializer`**: Специальный м��ни-сериализатор, ����оторый разрешает изменять **только** поле `status`.
    > `fields = ('status',)` говорит: "Эт��т сериализатор работает только с полем `status`". Он используется в нашем `StatusUpdateViewSetMixin` для без��пасного обновления статуса.

### `signals.py` и `tasks.py` — Асинхронные уведомления

Это самая элегантная часть нашей архитектуры.

-   **`tasks.py`**: Содержит **одну универсальную** Celery-задачу `send_generic_status_change_email`.
    > **Как она ��аб��тает?** Она принимает ID типа контента и ID объекта. С помощью `ContentType.objects.get_for_id(content_type_id)` она "узнает", с какой моделью (Mortgage, Policy и т.д.) нужно работать, и динамически получает нужный объект. Это позволяет ей быть абсолютно универсальной.

-   **`signals.py`**: Содержит "фабрику сигналов" `register_status_change_signals`.
    > **Как она работает?** Эта функция принимает класс модели (например, `Mortgage`) и "вешает" на него ��ва обработчика:
    > 1.  `pre_save`: Перед сохранением объекта он запоминает его старый статус в `instance._old_status`.
    > 2.  `post_save`: Сразу после сохранения он сравнивает старый статус с новым. Если они отличаются, он вызывает нашу универсальную Celery-задачу, передавая ей всю необходимую информацию.

> **Пример "активации" уведомлений в `apps/policies/apps.py`:**
> Всего три строки кода, и наша модель `Policy` начнет автоматически отправлять email при изменении статуса!
> ```python
> class PoliciesConfig(AppConfig):
>     # ...
>     def ready(self):
>         from commission_tracker.signals import register_status_change_signals
>         policy = self.get_model('Policy')
>         register_status_change_signals(policy)
> ```

---

## Структура приложений (`apps/`)

Каждая бизнес-сущность вынесена в отдельное Django-приложение. Новые сущности, такие как `policies` и `advisers`, создаются для соответствия требованиям страхового бизнеса.

-   `models.py`: Определяет структуру данных в базе — модели `Policy`, `Insurer`, `Adviser`.
-   `serializers.py`: Определяет, как данные будут выглядеть в API.
-   `api_views.py`: Определяет API-эндпоинты.
-   `apps.py`: Файл конфигурации, где мы "активируем" бизнес-логику, например, отправку уведомлений.
-   `urls.py`: Определяет URL-адреса для API.

### `apps.reports` — Модуль отчетов и прогнозирования

Это аналитическое ядро системы. Его задача — превращать сырые данные в ценную бизнес-информацию. От��еты будут переведены на новые модели (`Policy`, `Commission`) для предоставления точной аналитики по страхованию.

-   **`FinancialReportView`**: API-эндпоинт (`/api/reports/financial/`) для получения **агрегированного** финансового отчета.
    > **Как он работает?** Он принимает параметры `start_date` и `end_date` и рассчитывает общие суммы по заработанным и прогнозируемым комиссиям, а также KPI. Идеально подходит для дашбордов.

-   **`DetailedReportView`**: API-эндпоинт (`/api/reports/detailed/`) для получения **детализированного** отчета по каждой комиссии.
    > **Как он работает?** Принимает те же параметры `start_date` и `end_date`, но возвращает полный список всех комиссий за период.
    > **Что он показывает по каждой комиссии?**
    > 1.  **Данные о комиссии**: Сумма и дата создания.
    > 2.  **Данные о полисе**: Статус (например, `ACTIVE`), номер, даты.
    > 3.  **Данные о страховом продукте**: Тип страхования, сумма покрытия.
    > 4.  **Данные о клиенте**: Имя, фамилия, email и телефон.
    > Этот отчет предоставляет исчерпывающую информацию для глубокого анализа и аудита.

Этот модуль является основой для построения сложных аналитических панелей на фронтенде.

---

## Бизнес-логика и процессы

Этот раздел объясняет, как архитектура реализует ключевые бизнес-требования.

### Роли пользователей и их ограничения

В системе есть несколько ролей, но ключевые для бизнес-логики — `Admin` и `Adviser`.

-   **`Adviser` (Финансовый консультант)**: Основной пользователь системы. Он может создавать клиентов и сделки (`Mortgage`, `Policy`) и управлять **т��лько ими**.
-   **`Admin` (Администратор)**: Имеет полный доступ ко всем данным в системе. Может просматривать и редактировать сделки всех консультантов, управлять пользователями и настройками.

**Как это реализовано в коде?**

За огр��ничение доступа отвечает наш кастомный класс разрешений `commission_tracker/permissions.py`:

```python
# commission_tracker/permissions.py
class IsOwnerOrAdmin(BasePermission):
    def has_object_permission(self, request, view, obj):
        # Администраторы (is_staff) могут видеть всё
        if request.user.is_staff:
            return True
        # Владелец объекта может его видеть
        return obj.user == request.user
```

Этот класс используется во всех `ViewSet`'ах. Когда `Adviser` пытается получить доступ к полису `/api/policies/5/`, этот код проверяет, является ли `obj.adviser.user` (пользователь, связанный с консультантом полиса №5) тем же самым, что и `request.user` (текущий залогиненный пользователь). Если нет — доступ запрещен.

### Жизненный цикл полиса и получение комиссии

Это основной бизнес-процесс в приложении.

1.  **Создание**: `Adviser` создает нового клиента, а затем для него — новый `Policy`. Полис получает начальный статус, например, `IN_REVIEW`.
2.  **Работа по полису**: `Adviser` работает с клиентом и страховщиком, и статус полиса меняется.
3.  **Активация полиса**: Когда полис успешно оформлен, `Adviser` через интерфейс меняет его статус на `ACTIVE`.
4.  **Расчет комиссии**: **Это ключевой момент.** Как только статус меняется на `ACTIVE`, в бэкенде срабатывает **сигнал**. Этот сигнал запускает логику в приложении `apps.commission`.
5.  **Создание объекта `Commission`**: Логика находит комиссионные правила и на основе данных полиса (`monthly_premium`, `coverage_amount`) рассчитывает сумму комиссии. Создается новый объект `Commission` в базе данных, связанный с этим полисом.
6.  **Распределение и выплата**: Созданный об��ект `Commission` может быть далее связан с `Retention` (удержание), `Clawback` (условия возврата) или `Bonus`, в зависимости от бизнес-правил.

Этот автоматизированный процесс гарантирует, что комиссии рассчитываются точно и прозрачно сразу после успешного завершения работы консультанта.

---

## Конфигурация и автоматизация

-   `.env` и `settings.py`: Все секретные настройки (ключи, пароли) вынесе��ы из кода в файл `.env`. Файл `settings.py` читает эти настройки, что делает проект безопасным. Часовой по��с проекта (`TIME_ZONE`) установлен в `'Europe/London'` для корректной работы с датами и временем в Англии.
-   `pyproject.toml`, `.flake8`: Файлы с настройками для `black`, `isort` и `flake8`. Эти инструменты автоматически форматируют код и проверяют его на ошибки.
-   `.github/workflows/ci.yml`: Настроен CI-пайплайн, кото��ый при каждом изменении кода автоматически запускает тесты и проверки качества. Это гарантирует, что в проект не попадет нерабочий код.

---

## API Документация

-   **drf-spectacular**: В проек�� интегрирована эта библиотека, которая автоматически создает интерактивную документацию для нашего API. Она доступна по адресу `/api/schema/swagger-ui/` и позволяет фронтенд-разработчикам просматривать все эндпоинты и даже тестировать их прямо из браузера.

---

# Project Structure

This document outlines the structure of the `commission-tracker` project.

## Directory Layout

```
commission-tracker/
├── commission_tracker/   # Django project configuration
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py       # Project settings
│   ├── urls.py           # Root URL configuration
│   ��── wsgi.py
├── products/             # App for managing products
├── sales/                # App for managing sales records
├── commissions/          # App for calculating commissions
├── reports/              # App for generating reports
│   ├── migrations/
��   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── models.py
│   ├── tests.py
│   └── views.py          # Report generation logic
│   └── urls.py           # URLs for the reports app
├── manage.py             # Django's command-line utility
└── PROJECT_STRUCTURE.md  # This file
```

## Application: `reports`

The `reports` application is responsible for generating and serving all business-related reports. It is designed to be a flexible and scalable module for performance analysis.

### Key Files

-   `views.py`: Contains the API views for reports. The main entry point is `FinancialReportView`.
-   `urls.py`: Defines the URL patterns for the reports API, starting with `/api/reports/financial/`.

### Integration

The `reports` app is integrated into the main project as follows:

1.  **`commission_tracker/settings.py`**: Added `'reports'` to `INSTALLED_APPS`.

    ```python
    // ...
    INSTALLED_APPS = [
        // ...
        'commissions',
        'reports',
    ]
    // ...
    ```

2.  **`commission_tracker/urls.py`**: Included the `reports` app's URLs under the `/api/reports/` path.

    ```python
    // ...
    urlpatterns = [
        // ...
        path('api/commissions/', include('commissions.urls')),
        path('api/reports/', include('reports.urls')),
    ]
    ```

Мы реализовали первую версию финансового отчета. Теперь у нас есть мощный инструмент для анализа производительности, который можно будет дальше развивать и усложнять.
